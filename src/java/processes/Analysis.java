package processes;

/*
The "Analysis" process involves the enrichment analysis through two options:
    - Some software default in BIGO enrichment (Ontologizer,...).
    - An enrichment algorithm given by the user.

Once the enrichment analysis results was generated in a folder path desired by
the user, will read and process the output of the enrichment analysis.

Finally, BIGO will generate the output process.
 */
import entities.Cluster;
import entities.Enrichment;
import entities.Ontologizer;
import entities.Processing;
import entities.Row;
import java.io.*;
import java.util.*;
import ontologizer.OntologizerCMD;

public class Analysis implements Serializable {

    private Enrichment enrich;  // Enrichment Object (Ontologizer, ...).
    private Processing process; // Process Object (Output processing enrichment analysis).

    //Constructor
    public Analysis(Enrichment enrich, Processing process) {
        this.enrich = enrich;
        this.process = process;
    }

    //Gets - Sets
    public Enrichment getEnrich() {
        return enrich;
    }

    public void setEnrich(Enrichment enrich) {
        this.enrich = enrich;
    }

    public Processing getProcess() {
        return process;
    }

    public void setProcess(Processing process) {
        this.process = process;
    }

    // Main method of the analysis process that will execute all relevant transactions.    
    public boolean start() throws IOException {
        // Run enrichment analysis software.
        boolean bSuccess = true;
        if (this.getEnrich() instanceof Ontologizer) {
            executeOntologizer((Ontologizer) this.getEnrich());
        }

        // Capture files generated by enrichment analysis in "fileBiclusters" attribute.
        File fFolder = new File(this.getProcess().getsFolder());
        this.getProcess().setFileBiclusters(fFolder.list());

        // Processing the output of enrichment analysis software.
        if (this.getProcess().getFileBiclusters().length == 0) { // Whether files generated in enrichment analysis, we can't do anything.
            System.out.println("No files found.");
            bSuccess = false;
        } else {                                                 // If there files generated in enrichment analysis, we process the output.
            try {
                addAllBiclustersOntologizer();
            } catch (Exception e) {
                System.out.println("No data biclusters found.");
            }
        }
        return bSuccess;                                        // Return whether it hasn't benn able to run the enrichment analysis.
    }

    // Main method of the analysis process that will execute all relevant transactions.    
    public boolean startProvide() throws IOException {
        // Run enrichment analysis software.
        boolean bSuccess = true;

        // Capture files generated by enrichment analysis in "fileBiclusters" attribute.
        File fFolder = new File(this.getProcess().getsFolder());
        this.getProcess().setFileBiclusters(fFolder.list());

        // Processing the output of enrichment analysis software.
        if (this.getProcess().getFileBiclusters().length == 0) { // Whether files generated in enrichment analysis, we can't do anything.
            System.out.println("No files found.");
            bSuccess = false;
        } else {                                                 // If there files generated in enrichment analysis, we process the output.
            try {
                addAllBiclustersOntologizerProvide();
            } catch (Exception e) {
                System.out.println("No data biclusters found.");
            }
        }
        return bSuccess;                                        // Return whether it hasn't benn able to run the enrichment analysis.
    }

    /*
    ##############################################
    # METHODS: RUNS ENRICHMENT ANALYSIS SOFTWARE #
    ##############################################
    If you want to add a new enrichment analysis software, you must create a method similar to this for that software.
     */
    //Ontologizer method.
    public void executeOntologizer(Ontologizer oObject) {
        //CorrectionTest = Bonferroni, None, Westfall-Young-Single-Step
        // If correction test isn't correct, Ontologizer will execute with Bonferroni test (default).
        if (!oObject.getCorrectionTest().equals("None") && !oObject.getCorrectionTest().equalsIgnoreCase("Westfall-Young-Single-Step")) {
            oObject.setCorrectionTest("Bonferroni");
        }

        //threshold between 0 and 0.5
        //If threshold is incorrect, Ontologizer will execute a threshold = 0.001 (default).
        Double thres = Double.parseDouble(oObject.getThreshold());
        if (thres < 0 || thres > 0.5) {
            oObject.setThreshold("0.001");
        }

        // Calculation = Parent-Child-Union, Parent-Child-Intersection, Term-For-Term
        // If calculation method is incorrect, Ontologizer will execute with Term-Form-Term (default).
        if (!oObject.getCalculation().equals("Parent-Child-Union") && !oObject.getCalculation().equals("Parent-Child-Intersection")) {
            oObject.setCalculation("Term-For-Term");
        }

        // Ontologizer parameters.
        //String[] params = {"-a", oObject.getAnnoFile(), "-g", oObject.getOboFile(), "-s", oObject.getDataDir(), "-p", oObject.getPopFile(), "-c", oObject.getCalculation(), "-m", oObject.getCorrectionTest(), "-o", oObject.getOutDir(), "-d", oObject.getThreshold(), "-n"};
        String[] params = {"-a", oObject.getAnnoFile(), "-g", oObject.getOboFile(), "-s", oObject.getDataDir(), "-p", oObject.getPopFile(), "-c", oObject.getCalculation(), "-m", oObject.getCorrectionTest(), "-o", oObject.getOutDir()};

        // Ontologizer runs!!
        OntologizerCMD.main(params);

    }

    /*
    ###################################################
    # METHODS: OUTPUT OF ENRICHMENT ANALYSIS SOFTWARE #
    ###################################################
    It has created a class "cluster" to differentiate one from another cluster. The name assigned to each cluster will be the file name.    
    All clusters are stored in a set of clusters.
     */
    public void addAllBiclustersOntologizer() throws IOException {
        for (int x = 0; x < this.getProcess().getFileBiclusters().length; x++) {
            String sFile = this.getProcess().getFileBiclusters()[x];
            if (sFile.contains("table")) {              // I take only the "table" files generated by Ontologizer.               
                List<String> listNames = new ArrayList();
                List<String> listCopyNames = new ArrayList();
                for (Cluster clust : this.getProcess().getoConversion().getcGroupGenes()) {
                    listNames.add(clust.getsNameBicluster());
                }
                listCopyNames.addAll(listNames);

                String sFileAux = sFile.substring(6, sFile.length());

                for (int i = 0; i < sFileAux.length() && !listCopyNames.isEmpty(); i++) {
                    for (String nombre : listNames) {
                        if (nombre.length() - 1 < i) {
                            listCopyNames.remove(nombre);
                        } else {
                            if (sFileAux.charAt(i) != nombre.charAt(i)) {
                                listCopyNames.remove(nombre);
                            }
                        }
                    }
                    if (!listCopyNames.isEmpty()) {
                        listNames.clear();
                        listNames.addAll(listCopyNames);
                    }
                }

                int minLength = 99999;
                int pos = -1;
                for (int i = 0; i < listNames.size(); i++) {
                    if (listNames.get(i).length() < minLength) {
                        minLength = listNames.get(i).length();
                        pos = i;
                    }
                }

                String sNameBicluster = listNames.get(pos);

                Set<Row> cBicluster = readDataColumn(this.getProcess().getsFolder() + "//" + this.getProcess().getFileBiclusters()[x]); // Construyo el bicluster a raiz de su fichero bicluster.
                if (!cBicluster.isEmpty()) {
                    this.getProcess().getcConjuntoTerminos().add(new Cluster(cBicluster, sNameBicluster));
                }
            }
        }
    }

    public void addAllBiclustersOntologizerProvide() throws IOException {
        for (int x = 0; x < this.getProcess().getFileBiclusters().length; x++) {
            String sFile = this.getProcess().getFileBiclusters()[x];
            //if (sFile.contains("table")) {              // I take only the "table" files generated by Ontologizer.               
            List<String> listNames = new ArrayList();
            List<String> listCopyNames = new ArrayList();
            for (Cluster clust : this.getProcess().getoConversion().getcGroupGenes()) {
                listNames.add(clust.getsNameBicluster());
            }
            listCopyNames.addAll(listNames);

            String sNameBicluster = "";
            //String sFileAux = sFile.substring(6, sFile.length());

            //Que hacía este código?? Aqui puede petar
            for (int i = 0; i < sFile.length() && !listCopyNames.isEmpty(); i++) {
                for (String nombre : listNames) {
                    if (nombre.length() - 1 < i) {
                        listCopyNames.remove(nombre);
                    } else {
                        if (sFile.charAt(i) != nombre.charAt(i)) {
                            listCopyNames.remove(nombre);
                        }
                    }
                }
                if (!listCopyNames.isEmpty()) {
                    listNames.clear();
                    listNames.addAll(listCopyNames);
                }
            }

            int minLength = 99999;
            int pos = -1;
            for (int i = 0; i < listNames.size(); i++) {
                if (listNames.get(i).length() < minLength) {
                    minLength = listNames.get(i).length();
                    pos = i;
                }
            }

            sNameBicluster = listNames.get(pos);

            Set<Row> cBicluster = readDataColumn(this.getProcess().getsFolder() + "//" + this.getProcess().getFileBiclusters()[x]); // Construyo el bicluster a raiz de su fichero bicluster.
            if (!cBicluster.isEmpty()) {
                this.getProcess().getcConjuntoTerminos().add(new Cluster(cBicluster, sNameBicluster));
            }

        }
        //}
    }

    /*
     Method for processing clusters, creating an object to represent the cluster.
     */
    public static Set<Row> readDataColumn(String file) throws IOException {
        Set<Row> output = new HashSet();
        File f = new File(file);
        BufferedReader br = new BufferedReader(new FileReader(f));
        String cadena = br.readLine(); //I delete header. This header always generated by Ontologizer.
        while ((cadena = br.readLine()) != null) {
            output.add(stringProcessingOntologizer(cadena));
        }
        
        return output;
    }

    /*
     The string divided into the corresponding attributes of the row (GO term), were taken into account attributes: idGO, popTotal, poopTerm and name.
    Other attributes will be discared.
     */
    public static Row stringProcessingOntologizer(String sCadena) {
        String idGO = sCadena.substring(0, sCadena.indexOf("\t"));
        sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        int popTotal = Integer.parseInt(sCadena.substring(0, sCadena.indexOf("\t")));
        sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        int popTerm = Integer.parseInt(sCadena.substring(0, sCadena.indexOf("\t")));
        sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        //Study total, study term, p, p.adjusted, p.min no influyen en los objetos Row porque no nos serviran para este estudio.
        for (int i = 0; i < 2; i++) {
            sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());
        }
        double pValue = Double.parseDouble(sCadena.substring(0, sCadena.indexOf("\t")));
        sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        double pValueAdjusted = Double.parseDouble(sCadena.substring(0, sCadena.indexOf("\t")));
        sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        double pValueMin = Double.parseDouble(sCadena.substring(0, sCadena.indexOf("\t")));
        sCadena = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        String name = sCadena.substring(sCadena.indexOf("\t") + 1, sCadena.length());

        return new Row(idGO, popTotal, popTerm, pValue, pValueAdjusted, pValueMin, name);
    }
}
